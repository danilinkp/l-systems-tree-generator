\chapter{Аналитическая часть}

\section{Общая характеристика предметной области}
Визуализация трёхмерных растительных объектов является одной из важнейших задач современной компьютерной графики. Деревья составляют неотъемлемую часть виртуальных сцен в природных ландшафтах, архитектурных симуляциях и игровых средах. Качество их визуального представления напрямую влияет на уровень погружения и реалистичность изображения.

Значимость задачи визуализации деревьев обусловлена широким спектром прикладных направлений. В игровой индустрии и симуляторах виртуальной реальности требуется отображать обширные сцены с растительностью в реальном времени, обеспечивая баланс между качеством картинки и производительностью. В архитектурной визуализации и ландшафтном дизайне точное визуальное представление деревьев позволяет оценить визуальную привлекательность проекта и его интеграцию в окружающую среду. В кинематографе и анимации требуется фотореалистичный рендеринг сложных растительных сцен с корректной обработкой освещения, теней и материалов.

Для эффективной визуализации деревьев необходимо решить несколько взаимосвязанных проблем. Во-первых, требуется компактное представление геометрии: дерево может содержать десятки тысяч ветвей и листьев, что создаёт высокую нагрузку на графический конвейер. Во-вторых, необходимо обеспечить управляемость формой объекта через параметры, влияющие на структуру кроны, углы ветвления, густоту листвы. В-третьих, система визуализации должна корректно обрабатывать параметры освещения и материалов, обеспечивая реалистичное взаимодействие света с поверхностями.

Традиционный подход, при котором художник-конструктор вручную создаёт полигональную модель дерева и затем визуализирует её стандартными средствами, сталкивается с рядом ограничений. Ручное моделирование крайне трудоёмко и не позволяет быстро экспериментировать с различными формами деревьев. Кроме того, созданные вручную модели сложно параметризовать: изменение формы кроны или высоты дерева потребует повторной работы художника.

Эти ограничения мотивируют переход к процедурным методам генерации, которые позволяют автоматически создавать сложные геометрические структуры на основе набора правил и параметров. Процедурный подход решает проблемы масштабируемости и разнообразия, позволяя генерировать целые экосистемы уникальных растений.

\section{Сравнительный анализ существующих методов процедурной генерации деревьев}

\subsection{Обзор основных подходов}
Существует несколько базовых подходов к процедурной генерации трёхмерных деревьев, каждый из которых обладает своими преимуществами и ограничениями.

Фрактальные методы основаны на рекурсивном применении правил ветвления. Классический пример --- построение дерева путём многократного деления ветвей на более мелкие с уменьшением длины и толщины. Такой подход позволяет создавать визуально правдоподобные структуры с минимальным набором параметров. Однако фрактальные деревья обладают излишней регулярностью и не всегда точно воспроизводят морфологию реальных растений~\cite{mandelbrot1982fractal}.

Методы на основе пространственной колонизации (Space Colonization Algorithm) моделируют рост дерева в направлении источников питания. Алгоритм размещает в пространстве множество точек-аттракторов, к которым стремятся растущие ветви. Данный метод позволяет получать органичные формы с естественным распределением ветвей, однако требует сложной настройки параметров и вычислительно затратен~\cite{runions2007space}.

Грамматические методы описывают структуру дерева через формальные правила подстановки символов. Наиболее известным представителем являются L-системы (Lindenmayer systems), предложенные биологом Аристидом Линденмайером в 1968 году для моделирования развития растений. L-системы представляют собой параллельные системы переписывания строк, где каждый символ одновременно заменяется согласно заданным правилам~\cite{prusinkiewicz1990}.

Методы на основе физического моделирования симулируют биологические процессы роста с учётом гравитации, направления источника света и конкуренции за ресурсы. Такие подходы дают наиболее реалистичные результаты, но требуют значительных вычислительных ресурсов и сложны в реализации~\cite{prusinkiewicz2006growth}.

\subsection{Сравнительный анализ методов}

При выборе метода генерации для решения поставленной задачи необходимо учитывать следующие критерии: вычислительная сложность, число управляющих параметров, возможность интерактивного редактирования и гибкость управления формой. Результаты сравнительного анализа представлены в таблице~\ref{tab:generation_methods}.

\begin{table}[h!]
    \small
    \centering
    \caption{Сравнение методов процедурной генерации деревьев}
    \label{tab:generation_methods}
    \begin{tabularx}{\textwidth}{|X|X|X|X|X|}
        \hline
        \textbf{Критерий} & \multicolumn{4}{c|}{\textbf{Метод}} \\
        \cline{2-5}
        & \textbf{Фракталы} & \textbf{Space Colonization} & \textbf{L-системы} & \textbf{Физ. модели} \\
        \hline
        Вычислительная сложность                              & Линейная относительно числа сегментов & Квадратичная                    & Линейная относительно длины строки & Высокая: требуется итеративная симуляция временных шагов \\
        \hline
        Число управляющих параметров                          & 3--5                                  & 8-12                            & 5-10                               & >15                                                      \\
        \hline
        Инкременталь\-ное обновление при изменении параметров & Возможно                              & Невозможно (полная регенерация) & Возможно                           & Невозможно (полная регенерация)                          \\
        \hline
        Возможность задания асимметричной формы кроны         & Ограничена                            & Да                              & Да                                 & Да                                                       \\
        \hline
        Разнообразие при одних параметрах                     & Нет                                   & Ограниченная                    & Да (стохастические L-системы)      & Да                                                       \\
        \hline
    \end{tabularx}
\end{table}

Фрактальные методы имеют минимальное число параметров и линейную сложность, но ограничены в создании асимметричных форм; метод на основе пространственной колонизации обладает квадратичной сложностью и не поддерживает инкрементальное обновление, что делает метод непригодным для интерактивного редактирования; физические модели требуют большого числа параметров и полной пересимуляции при изменении любого из них, согласно данным, представленным в таблице~\ref{tab:generation_methods}.

L-системы сочетают линейную сложность, умеренное число параметров, возможность инкрементального обновления и высокую гибкость в задании формы (таблица~\ref{tab:generation_methods}). Таким образом, для реализации системы визуализации с графическим интерфейсом выбран метод на основе L-системы.

\subsection{L-системы как основа для генерации деревьев}

L-система представляет собой формальную грамматику, которая определяется тройкой~\eqref{eq:grammatica}~\cite{prusinkiewicz1990}.

\begin{equation}
    \label{eq:grammatica}
    G = (V, \omega, P),
\end{equation}

где:
\begin{itemize}
    \item $V$ --- алфавит (набор символов);
    \item $\omega$ --- аксиома (начальная строка);
    \item $P$ --- набор правил продукции вида $a \to w$, где $a \in V$ и $w$ — строка символов из $V$.
\end{itemize}

Генерация структуры дерева происходит итеративно. На каждом шаге все символы строки одновременно заменяются согласно правилам продукции. После $n$ итераций получается строка, которая отражает геометрическую структуру дерева.

Для визуализации трёхмерных структур используется черепашья графика --- метод интерпретации строки L-системы как последовательности команд для виртуального исполнителя. Черепаха имеет позицию в пространстве и ориентацию, определяемую тремя ортогональными векторами: направлением движения, левым направлением и направлением вверх.

Базовый набор команд включает:
\begin{itemize}
    \item \texttt{F} --- движение вперёд с рисованием линии (создание сегмента ветви);
    \item \texttt{f} --- движение вперёд без рисования;
    \item \texttt{+} --- поворот влево на заданный угол;
    \item \texttt{-} --- поворот вправо на заданный угол;
    \item \texttt{\&} --- наклон вниз;
    \item \texttt{\^} --- наклон вверх;
    \item \texttt{/} --- поворот по часовой стрелке относительно оси движения;
    \item \texttt{\textbackslash} --- поворот против часовой стрелки относительно оси движения;
    \item \texttt{{[}} --- сохранение текущего состояния черепахи в стек;
    \item \texttt{{]}} --- восстановление состояния из стека.
\end{itemize}

Команды <<\texttt{{[}}>> и <<\texttt{{]}}>> позволяют моделировать ветвление: при встрече символа <<\texttt{{[}}>> текущая позиция и ориентация сохраняются, система генерирует боковую ветвь, а затем при встрече <<\texttt{{]}}>> возвращается к сохранённой точке для продолжения роста основной ветви.

\subsection{Типы L-систем}
Детерминированные контекстно-свободные L-системы (D0L-системы) являются вариантом, где каждому символу соответствует ровно одно правило продукции, не зависящее от окружающих символов.

Пример D0L-системы, заданной тройкой~\eqref{eq:l-sys_exmp}:
\begin{align}
    \label{eq:l-sys_exmp}
    V      & = \{F, +, -, [, ]\}; \nonumber \\
    \omega & = F; \nonumber                 \\
    P      & :\ F \to F[+F]F[-F][F].
\end{align}

Визуализация результата работы L-системы~\eqref{eq:l-sys_exmp} после пяти итераций при угле ветвления $20^\circ$ приведена на рисунке~\ref{fig:l-system-example}.
\clearpage
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.6]{images/plant 2 (1).pdf}
    \caption{Визуализация D0L-системы после 5 итераций (угол ветвления — $20\degree$)}
    \label{fig:l-system-example}
\end{figure}

Стохастические L-системы вводят элемент случайности, позволяя каждому символу иметь несколько альтернативных правил продукции с заданными вероятностями. Это обеспечивает визуальное разнообразие генерируемых структур.

Пример стохастической L-системы приведён в выражении~\eqref{eq:stoh_l-sys}:
\begin{align}
    \label{eq:stoh_l-sys}
    V      & = \{F, +, -, [, ]\}; \nonumber \\
    \omega & = F; \nonumber                 \\
    P      & :
    \begin{cases}
        F \to F[+F]F[-F]F \quad & p = 0{,}7, \\
        F \to F[+F]F \quad      & p = 0{,}3.
    \end{cases}
\end{align}
При каждом шаге подстановки для символа $F$ случайным образом выбирается одно из правил в соответствии с заданными вероятностями. В результате при одинаковых параметрах система генерирует различные по форме деревья.


Контекстно-зависимые L-системы учитывают символы, предшествующие и следующие за заменяемым. Правила имеют вид $A\mathord{<}B\mathord{>}C \rightarrow D$, означающее, что символ $B$ заменяется на $D$ только при условии, что слева от него находится $A$, а справа --- $C$.

Параметрические L-системы позволяют ассоциировать с каждым символом числовые параметры, изменяющиеся в процессе генерации. Это даёт возможность моделировать плавное уменьшение толщины ветвей, изменение углов ветвления в зависимости от порядка ветви и другие биологически реалистичные эффекты.

Пример параметрической L-системы, заданной набором правил~\eqref{eq:param_l-sys}:
\begin{align}
    \label{eq:param_l-sys}
    \omega & = F(1); \nonumber \\
    P      & :
    \begin{cases}
        F(s) \to F(0{,}7s)[+F(0{,}7s)][-F(0{,}7s)], & s > s_{\min},         \\
        F(s) \to F(s),                              & s \leqslant s_{\min},
    \end{cases}
\end{align}

где параметр $s$ задаёт относительную длину сегмента, а порог $s_{\min}$ ограничивает глубину ветвления.

В рамках данной работы используется детерминированная контекстно-свободная L-система (D0L-система). Такой выбор обусловлен тем, что D0L-системы обладают линейной вычислительной сложностью по длине строки, просты в реализации и отладке, а также обеспечивают предсказуемый результат при фиксированных параметрах. Это важно для интерактивной визуализации, когда пользователь ожидает воспроизводимого эффекта при повторном запуске генерации с одинаковыми настройками.

Стохастические и контекстно-зависимые L-системы дают больше визуального разнообразия и позволяют учитывать взаимодействие между частями структуры, однако существенно усложняют алгоритм и интерпретацию результата. Для поставленной задачи --- визуализации одиночного дерева с возможностью управления базовыми параметрами формы --- возможностей D0L-системы оказывается достаточно.

\section{Основные понятия и обозначения}

Визуализация трёхмерной сцены представляет собой процесс преобразования математической модели объектов в двумерное растровое изображение. Данный процесс включает в себя геометрические преобразования, удаление невидимых поверхностей, расчёт освещённости и построение теней.

Для формализации описания алгоритмов введена следующая система обозначений:
\begin{itemize}
    \item $P(x, y, z)$ --- точка на поверхности объекта в мировых координатах;
    \item $\vec{N}$ --- единичный вектор нормали к поверхности в точке $P$;
    \item $\vec{L}$ --- единичный вектор направления на источник света;
    \item $\vec{V}$ --- единичный вектор направления на наблюдателя (камеру);
    \item $\vec{R}$ --- единичный вектор отражённого света;
    \item $I$ --- итоговая интенсивность (цвет) пикселя.
\end{itemize}


\section{Методы рендеринга (синтеза изображений)}
Существует два фундаментальных подхода к синтезу изображений: трассировка лучей (ray-tracing) и растеризация (rasterization).

\subsection{Трассировка лучей}
Трассировка лучей моделирует физический путь распространения света. Для каждого пикселя экрана строится луч из точки наблюдения, и находится ближайшая точка пересечения с объектами сцены. Цвет пикселя определяется путём рекурсивного пускания вторичных лучей (отражение, преломление, тени). Вычислительная сложность: $O(N_{pixels} \cdot M_{objects})$~\cite{cgpp2018}.

\subsection{Растеризация}
Растеризация основана на проекции геометрических примитивов (обычно треугольников) на плоскость экрана. Для каждого примитива определяется набор пикселей, который он покрывает. Процесс растеризации включает трансформацию вершин и интерполяцию атрибутов внутри примитива. Вычислительная сложность: $O(M_{objects} \cdot K_{pixels\_per\_object})$~\cite{fundamentals2021}.

\subsection{Сравнительный анализ методов рендеринга}
Сравнительный анализ методов представлен в таблице~\ref{tab:rendering_methods}.
\clearpage
\begin{table}[H]
    \small
    \caption{Сравнение методов рендеринга}
    \label{tab:rendering_methods}
    \begin{tabularx}{\textwidth}{|X|X|X|}
        \hline
        \textbf{Критерий} & \multicolumn{2}{c|}{\textbf{Метод}} \\
        \cline{2-3}
        & \textbf{Растеризация} & \textbf{Трассировка лучей} \\
        \hline
        Базовый принцип & Перебор объектов сцены & Перебор пикселей экрана \\
        \hline
        Вычислительная сложность & Линейная от числа полигонов & Логарифмическая от числа полигонов (при использовании ускоряющих структур), линейная от разрешения \\
        \hline
        Глобальное освещение & Требует сложных аппроксимаций & Реализуется естественно \\
        \hline
        Применимость для L-систем & Высокая (быстрый вывод множества мелких деталей) & Средняя (требует построения BVH-деревьев) \\
        \hline
    \end{tabularx}
\end{table}

Для задачи интерактивной визуализации процедурных деревьев, содержащих большое количество полигонов, подходящим методом является растеризация, трассировка лучей, обеспечивая фотореалистичность, обладает избыточной вычислительной сложностью для поставленной задачи, согласно данным, представленным в таблице~\ref{tab:rendering_methods}.


\section{Алгоритмы удаления невидимых граней}

Задача удаления невидимых граней заключается в определении видимых частей объектов сцены для заданной точки наблюдения. Существуют два основных подхода: алгоритмы пространства объектов, определяющие видимость геометрии до растеризации, и алгоритмы пространства изображения, работающие на уровне пикселей.

\subsection{BSP-дерево}
BSP-дерево (Binary Space Partitioning) является представителем алгоритмов пространства объектов и реализует метод художника --- рисование объектов от дальних к ближним с перекрытием ранее нарисованных элементов~\cite{fundamentals2021}.

Алгоритм использует предварительно построенное бинарное дерево, где каждый узел содержит треугольник и соответствующую плоскость разбиения. Плоскость делит пространство на две полуплоскости: положительную и отрицательную. Все треугольники распределяются по поддеревьям в зависимости от того, в какой полуплоскости они находятся. Если треугольник пересекает плоскость разбиения, он разрезается на несколько частей.

Обход дерева для рендеринга выполняется рекурсивно: если камера находится в отрицательной полуплоскости узла, сначала рисуется положительное поддерево, затем треугольник узла, затем отрицательное поддерево. Если камера в положительной полуплоскости --- порядок обратный. Этот порядок гарантирует корректную видимость независимо от положения камеры.

На рисунке~\ref{fig:bsp-tree} представлен пример построения BSP-дерева.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.65]{images/bsp-tree.pdf}
    \caption{Пример построения BSP-дерева}
    \label{fig:bsp-tree}
\end{figure}

Ограничения: BSP-дерево строится как предобработка за время $O(N\log N)$, где $N$ --- число треугольников. Структура неизменна после построения, что делает метод непригодным для динамических сцен. Разрезание треугольников увеличивает число примитивов, а эффективность зависит от порядка добавления треугольников в дерево.

\subsection{Z-буффер}

Z-буфер --- двумерный массив, параллельный выходному изображению, в котором для каждого пикселя хранится скалярное значение глубины, представляющее расстояние от центра проекции до видимой поверхности. Это алгоритм пространства изображения, работающий на уровне пикселей~\cite{fundamentals2021}.

При растеризации треугольника для каждого покрываемого пикселя вычисляется глубина $z$ методом интерполяции. Новая поверхность может перекрыть пиксель только если её глубина меньше текущего значения в буфере. В этом случае обновляются как цвет в кадровом буфере, так и значение в Z-буфере. Это обеспечивает неявное определение видимости --- корректный порядок рисования определяется автоматически во время растеризации, без предварительной сортировки объектов.

После завершения рендеринга z-буфер описывает первое пересечение луча, проходящего из центра проекции через каждый пиксель. Это позволяет использовать z-буфер не только для определения видимости, но и для последующих проходов рендеринга.

На рисунке~\ref{fig:z-buffer} представлен пример работы буфера глубины при растеризации двух треугольников.
\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.8]{images/z-buffer_exmp.pdf}
    \caption{Принцип работы буфера глубины при растеризации двух треугольников}
    \label{fig:z-buffer}
\end{figure}

Ограничения: если объекты перекрываются на уровне одного пикселя (например, на силуэтах), возникает ступенчатость. Кроме того, при ограниченной точности буфера глубины (обычно 24 бита) возможен эффект \textit{z-fighting} --- мерцание между двумя поверхностями с близкими значениями глубины.

Преимущества: z-буфер обеспечивает вычислительную сложность, пропорциональную только числу пикселей и независимую от числа объектов в сцене. Такой асимптотический выигрыш достигается за счёт постоянного расхода памяти на буфер глубины.


\subsection{Сравнительный анализ}

Результаты сравнения алгоритмов представлены в таблице~\ref{tab:hidden_surface}.
\clearpage
\begin{table}[H]
\small
\caption{Сравнение алгоритмов удаления невидимых граней}
\label{tab:hidden_surface}
\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\textbf{Критерий} & \multicolumn{2}{c|}{\textbf{Алгоритм}} \\
\cline{2-3}
& \textbf{BSP-дерево} & \textbf{Z-буфер} \\
\hline
Вычислительная сложность & $O(N)$ на кадр (обход дерева) & $O(N \times A)$, где $A$ — площадь проекции \\
\hline
Память & $O(N \log N)$ (структура дерева) & $O(R^2)$ (буфер глубины) \\
\hline
Предобработка & Требуется $O(N \log N)$ & Не требуется \\
\hline
Порядок рендеринга & Не зависит & Не зависит \\
\hline
Динамические сцены & Нет (требуется перестроение) & Полная поддержка \\
\hline
\end{tabularx}
\end{table}

Для данной работы выбран z-буфер, поскольку метод поддерживает динамические сцены, не требует предобработки и позволяет вычислять видимость во время растеризации. BSP-дерево требует перестроения при изменении геометрии, что неприемлемо для интерактивного редактирования параметров L-системы.

\section{Алгоритмы закраски}

\subsection{Модели освещения}
Для расчёта цвета поверхности используется модель освещения, описывающая взаимодействие света с материалом.

Модель Ламберта учитывает только диффузное рассеивание света. Яркость, которая вычисляется по формуле~\eqref{eq:i_diff}, не зависит от угла обзора \cite{cgpp2018}:
\begin{equation}
    \label{eq:i_diff}
    I_{diff} = k_d I_L (\vec{N} \cdot \vec{L}),
\end{equation}

где $k_d$ --- коэффициент диффузного отражения, $I_L$ --- интенсивность источника.

Модель Фонга добавляет зеркальный блик, зависящий от угла между вектором отражения $\vec{R}$ и вектором взгляда $\vec{V}$, и тогда интенсивность равна выражению~\eqref{eq:phong} \cite{cgpp2018}:
\begin{equation}
    \label{eq:phong}
    I_{spec} = k_s I_L (\vec{R} \cdot \vec{V})^\alpha,
\end{equation}

где $\vec{R} = 2(\vec{N} \cdot \vec{L})\vec{N} - \vec{L}$. Расчёт вектора $\vec{R}$ требует вычислительных затрат для каждого пикселя.

Модель Блинна-Фонга является модификацией модели Фонга. Вместо вектора отражения используется <<серединный вектор>> $\vec{H}$~\eqref{eq:blinn-phong}, который является биссектрисой между $\vec{L}$ и $\vec{V}$ \cite{cgpp2018}:

\begin{equation}
    \label{eq:blinn-phong}
    \vec{H} = \frac{\vec{L} + \vec{V}}{||\vec{L} + \vec{V}||}.
\end{equation}
Интенсивность блика рассчитывается как $(\vec{N} \cdot \vec{H})^\alpha$.

\subsection{Методы затенения}

Модель освещения определяет, как вычисляется яркость в отдельной точке поверхности. Однако для визуализации полигональных моделей необходимо распространить это значение по всему полигону. Существуют три основных подхода: плоское затенение, затенение по Гуро и затенение по Фонгу~\cite{gambetta2022}.

Плоское затенение использует одну нормаль (обычно усреднённую по грани) для расчёта освещённости всей поверхности полигона. Это быстро, но приводит к резким перепадам яркости на границах граней и визуально подчёркивает полигональную структуру \cite{gambetta2022}.

Затенение по Гуро вычисляет освещённость в вершинах с использованием усреднённых нормалей, а затем линейно интерполирует полученную интенсивность по поверхности полигона. Такой подход даёт плавные переходы цвета и снижает вычислительную нагрузку, поскольку модель освещения применяется только в вершинах. Однако он плохо передаёт зеркальные блики, особенно если они находятся между вершинами --- в таких случаях блик либо исчезает, либо размывается неестественно \cite{fundamentals2021}.

Затенение по Фонгу устраняет этот недостаток: вместо интерполяции интенсивности он интерполирует нормали от вершин к каждому пикселю, после чего вычисляет полную модель освещения непосредственно в фрагменте. Это обеспечивает точное отображение бликов и более реалистичную форму световых переходов, но требует значительных вычислительных ресурсов --- нормализация нормали и расчёт освещения выполняются для каждого пикселя~\cite{gambetta2022}.

На рисунке~\ref{fig:shading-comparison} приведён пример визуализации основных методов затенения.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/lighting_interpolation}
    \caption{Сравнение плоского затенения, затенения по Гуро и затенения по Фонгу}
    \label{fig:shading-comparison}
\end{figure}

\subsection{Выбор модели освещения для визуализации}

В таблице~\ref{tab:lighting_models} представлено сравнение моделей освещения.
\begin{table}[H]
\small
\caption{Сравнение моделей освещения}
\label{tab:lighting_models}
\begin{tabularx}{\textwidth}{|l|X|X|X|}
\hline
\textbf{Критерий} & \multicolumn{3}{c|}{\textbf{Модель}} \\
\cline{2-4}
& \textbf{Ламберт} & \textbf{Фонг} & \textbf{Блинн--Фонг} \\
\hline
Учитываемые компоненты & Только диффузное отражение & Диффузное + зеркальное& Диффузное + зеркальное \\
\hline
Зависимость от угла обзора & Нет & Да & Да \\
\hline
Вычислительная сложность & Низкая & Высокая & Умеренная\\
\hline
Визуальный реализм & Низкий & Высокий & Высокий \\
\hline
Подходящее применение & Базовое освещение, тени & Реалистичные блики при точном управлении & Реалистичные блики с улучшенной производительностью \\
\hline
\end{tabularx}
\end{table}

Для визуализации растительности выбрана модель Блинна-Фонга в сочетании с методом затенения по Фонгу. Серединный вектор $\vec{H}$ модели Блинна-Фонга может быть вычислен один раз для удалённого источника света и наблюдателя, что существенно сокращает количество операций на пиксель по сравнению с классической моделью Фонга. Метод затенения по Фонгу обеспечивает высокое визуальное качество благодаря точному отображению зеркальных бликов. Несмотря на большие вычислительные затраты (интерполяция трёх компонент нормали и полный расчёт модели освещения для каждого пикселя), эта комбинация критически важна для достоверной визуализации сложных полигональных моделей растений, где детали освещения существенно влияют на реалистичность изображения.

\section{Алгоритмы построения теней}
Тени необходимы для восприятия пространственной глубины и структуры дерева.

Теневые объёмы --- геометрический алгоритм, создающий объём пространства, находящийся в тени. Требует поиска силуэтных ребер модели и генерации дополнительной геометрии. Для высокополигональных моделей деревьев метод неприменим из-за высокой алгоритмической сложности~\cite{cgpp2018}.

Карты теней --- алгоритм, работающий в пространстве изображения. Основан на идее, что освещены только те точки, которые «видны» из источника света. Сцена рендерится с позиции источника света, записываются только значения глубины $z_{light}$. При финальном рендеринге точка $P$ переводится в систему координат источника света, её глубина $d$ сравнивается со значением из карты теней. Если $d > z_{light}$, точка в тени~\cite{cgpp2018}.

В таблице~\ref{tab:shadow_methods} представлено сравнение методов построения теней.
\begin{table}[H]
\small
\caption{Сравнение методов построения теней}
\label{tab:shadow_methods}
\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\textbf{Критерий} & \multicolumn{2}{c|}{\textbf{Метод}} \\
\cline{2-3}
& \textbf{Теневые объёмы} & \textbf{Карты теней} \\
\hline
Принцип работы & Геометрический: построение объёмов, блокирующих свет & На основе глубины: сравнение расстояний от источника света \\
\hline
Зависимость от геометрической сложности сцены & Да (требуется обработка всех силуэтных рёбер) & Нет (зависит только от разрешения карты теней) \\
\hline
Вычислительная сложность & Высокая для сложных моделей (например, деревьев с тысячами листьев) & Умеренная, фиксированная по геометрии (масштабируется с разрешением) \\
\hline
Требуемая дополнительная геометрия & Да (генерация теневых объёмов) & Нет \\
\hline
Подходящее применение & Простые сцены с чёткими границами теней & Сложные сцены, включая высокополигональную растительность \\
\hline
\end{tabularx}
\end{table}

В работе используется метод построения карты теней, так как его вычислительная сложность не зависит от количества листьев и ветвей дерева, а определяется только разрешением карты теней, согласно данным, представленным в таблице~\ref{tab:shadow_methods}.


\section{Вывод}
В аналитической части, было дано описание предметной области, рассмотрены существующие методы процедурной генерации деревьев, было дано обоснование выбора L-систем в качестве метода генерации дерева и описаны основные методы и алгоритмы рендеринга. В качестве алгоритма для рендеринга изображения была выбрана растеризация, в качестве алгоритма удаления невидимых граней --- z-буфер, в качестве модели затенения --- модель Блинна-Фонга, а для построения теней --- алгоритм построения карты теней.